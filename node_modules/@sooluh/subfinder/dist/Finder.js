"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dns_1 = __importDefault(require("dns"));
const axios_1 = __importDefault(require("axios"));
const cloudflare_detect_1 = __importDefault(require("cloudflare-detect"));
class Finder {
    async crtsh(domain) {
        try {
            let response = await (0, axios_1.default)({
                method: "GET",
                url: "https://crt.sh/",
                params: {
                    q: `%.${domain}`,
                    output: "json"
                }
            });
            let result = {
                status: {
                    code: response.status,
                    text: response.statusText
                },
                body: response.data
            };
            return result;
        }
        catch (error) {
            let result = {
                status: {
                    code: 500,
                    text: "Oops! an error has occurred"
                },
                body: []
            };
            return result;
        }
    }
    async status(domain) {
        try {
            let response = await (0, axios_1.default)({
                url: "http://" + domain
            });
            return response.status;
        }
        catch (error) {
            if (error.response) {
                return error.response.status;
            }
            else {
                return 404;
            }
        }
    }
    async ips(domain) {
        return new Promise(function (resolve, reject) {
            dns_1.default.resolve4(domain, function (error, addresses) {
                if (error)
                    return resolve([]);
                resolve(addresses);
            });
        });
    }
    async parser(domain) {
        const self = this;
        let data = [];
        const parser = (body) => {
            let result = body.map(function (value) {
                return value.name_value.split("\n");
            });
            return result;
        };
        const unique = (body) => {
            let result = body.filter(function (value, index, array) {
                return array.indexOf(value) === index && !(new RegExp(/^\*/).test(value));
            });
            return result;
        };
        const { status, body } = await self.crtsh(domain);
        if (status.code !== 200) {
            let result = {
                data: [],
                error: status.text
            };
            return result;
        }
        if (body.length < 1) {
            let result = {
                data: [],
                error: null
            };
            return result;
        }
        let parsed = parser(body).flat();
        parsed = unique(parsed);
        parsed.sort(function (a, b) {
            let domainA = a.toUpperCase();
            let domainB = b.toUpperCase();
            return (domainA < domainB) ? -1 : (domainA > domainB) ? 1 : 0;
        });
        for (let index in parsed) {
            let subdomain = parsed[index];
            let status = await self.status(subdomain);
            let ips = await self.ips(subdomain);
            let cloudflare = await (0, cloudflare_detect_1.default)(subdomain);
            let result = {
                subdomain,
                status,
                ips,
                cloudflare
            };
            data.push(result);
        }
        let result = {
            data,
            error: null
        };
        return result;
    }
    async lookup(domain, callback) {
        const self = this;
        if (callback && typeof callback === "function") {
            try {
                let results = await self.parser(domain);
                callback(results.data, results.error);
            }
            catch (error) {
                callback([], error);
            }
            return;
        }
        return new Promise(async function (resolve, reject) {
            try {
                let results = await self.parser(domain);
                resolve(results.data);
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
exports.default = Finder;
